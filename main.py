import os
import warnings
import re
import json

from analyser import ProjectAnalyzer
from engine import repair_snippet
from verifier import run_pat_verification

warnings.filterwarnings("ignore", category=FutureWarning)

MODELS_DIR = "models"
OUTPUT_DIR = "repaired_models"
JSON_LOG = "mismatch_traces.json"

def sanitize_pat_syntax(content):
    """
    Cleans up common LLM syntax hallucinations for PAT CSP#.
    """
    # 1. Fix Double Arrows: "-> Node() -> Node()" -> "-> Node()"
    content = re.sub(r'(->\s*\w+\(\))\s*->\s*\w+\(\)', r'\1', content)
    
    # 2. Choice Operator Fix: PAT lines within a choice block must not end in ';'
    lines = content.split('\n')
    fixed_lines = []
    for line in lines:
        stripped = line.strip()
        if '->' in stripped and stripped.endswith(')'):
            line = line.rstrip(';')
        fixed_lines.append(line)
    
    return "\n".join(fixed_lines)

def repair_model_file(model_name, analyzer):
    model_path = os.path.join(MODELS_DIR, model_name)
    repaired_path = os.path.join(OUTPUT_DIR, f"repaired_{model_name}")

    if not os.path.exists(model_path):
        print(f"‚ùå Model file {model_name} not found.")
        return

    with open(model_path, "r") as f:
        current_full_content = f.read()

    # Loop through the dynamic errors found by the verifier
    for entry in analyzer.errors:
        assertion_text = entry.get('assertion')
        print(f"üõ†Ô∏è  Calling Gemini for full-context repair on: {assertion_text}")

        repaired_content = repair_snippet(current_full_content, "General PAT Repair", assertion_text)

        if repaired_content:
            current_full_content = sanitize_pat_syntax(repaired_content)
            print(f"   ‚úÖ Content updated and sanitized.")

    if not os.path.exists(OUTPUT_DIR):
        os.makedirs(OUTPUT_DIR)

    with open(repaired_path, "w") as f:
        f.write(current_full_content)
    
    print(f"‚ú® Final repaired model saved: {repaired_path}")

def run_pipeline():
    # Ensure directories exist
    if not os.path.exists(MODELS_DIR):
        os.makedirs(MODELS_DIR)
        print(f"üìÅ Created '{MODELS_DIR}' directory. Please place your .csp models inside.")
        return

    target_models = [f for f in os.listdir(MODELS_DIR) if f.endswith(".csp")]

    if not target_models:
        print("‚ö†Ô∏è No .csp files found in the models directory.")
        return

    for model_name in target_models:
        model_path = os.path.join(MODELS_DIR, model_name)
        print(f"\nüöÄ Pipeline Entry: {model_name}")

        # 1. RUN VERIFICATION (Generates JSON dynamically)
        has_errors = run_pat_verification(model_path, JSON_LOG)

        # 2. RUN REPAIR (If verification failed)
        if has_errors:
            # Load the fresh JSON generated by the verifier
            analyzer = ProjectAnalyzer(JSON_LOG)
            repair_model_file(model_name, analyzer)
            
            # Optional: You could recursively call run_pat_verification here 
            # on the newly saved file in OUTPUT_DIR to see if Gemini actually fixed it!
        else:
            print(f"‚è≠Ô∏è  Skipping repair for {model_name} (No assertions failed).")

if __name__ == "__main__":
    run_pipeline()